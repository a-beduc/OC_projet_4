from datetime import datetime
from models.base_model import _BaseModel
from models.match import Match
from typing import Dict, Optional, Set, Tuple


class Round(_BaseModel):
    def __init__(self,
                 name: str,
                 matches_pairs: Optional[Set[Tuple[str, str]]] = None,
                 save_to_db: bool = True):
        """
        Initialise a new instance of a Round

        :param name: format : 'Round_<number>'
        :param matches_pairs: A set composed of pairs of players_id {('p_1', 'p_2'),('p_3','p_4')} that will be used to
        create matches of the rounds.
         2024/09/14 : As of today, the pair are generated by an instance of pairing model
        :param save_to_db: If true, it wills save the object into the database
        """
        super().__init__()
        self.name = name
        self.time_start = str(datetime.now())
        self.time_end = None
        self.is_finished = False
        self.matches = []
        if matches_pairs:
            self.matches_pairs = matches_pairs
            self.create_matches()
        if save_to_db:
            self.save_to_database()

    @classmethod
    def _create_instance_from_json(cls,
                                   item_data: Dict[str, object],
                                   round_id: str,
                                   save_to_db: bool = False):
        """
        Create a round object from a json dictionary.
        Instantiate matches from their corresponding id found in the database
        :param item_data:
        :param round_id:
        :param save_to_db: must be false to avoid copy of round instance in database
        :return: An instance of Player
        """
        instance = cls(name=item_data["name"],
                       save_to_db=False)
        instance.software_id = round_id
        instance.time_start = item_data["time_start"]
        instance.time_end = item_data["time_end"]
        instance.is_finished = item_data["complete"]
        instance.matches = [Match.from_json(match_id) for match_id in item_data["matches"]]
        return instance

    def _prepare_data_to_save(self) -> dict:
        """
        Prepare data to save in the database.
        :return: dictionary with data to save in the database
        """
        data = {
            "name": self.name,
            "time_start": self.time_start,
            "time_end": self.time_end,
            "complete": self.is_finished,
            "matches": [match.software_id for match in self.matches]
        }
        return data

    def create_matches(self):
        """
        Create Match Instance from pairs of players.
        :return:
        """
        self.matches.extend([Match(pair[0], pair[1]) for pair in self.matches_pairs])

    def end_round(self):
        """
        End the round if every match is finished
        Save the state of the round and the time it was completed in the database.
        """
        if not self.is_finished:
            if any(not match.is_finished for match in self.matches):
                raise ValueError(f"One or more matches are not finished.")
            self.time_end = str(datetime.now())
            self.is_finished = True
            self.save_to_database()
        else:
            raise ValueError("Round is already finished")

    def get_match_by_player_id(self, player_id: str):
        """
        Get a Match object in the Round where a Player_id is participating
        :param player_id:
        :return: Match object
        """
        return next((match for match in self.matches if player_id in match.score.keys()), None)
