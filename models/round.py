from datetime import datetime
from models.base_model import _BaseModel
from models.match import Match
from typing import Optional, Set, Tuple


class Round(_BaseModel):
    """
    2024/09/14 : It appears that Round or round is a name used for a built-in function, the name of the class might need
    to be changed
    """
    def __init__(self,
                 name: str,
                 matches_pairs: Optional[Set[Tuple[str, str]]] = None,
                 save_to_db: bool = True):
        """
        Initialise a new instance of a Round

        :param name: format : 'Round_<number>'
        :param matches_pairs: A set composed of pairs of players_id {('p_1', 'p_2'),('p_3','p_4')} that will be used to
        create matches of the rounds.
         2024/09/14 : As of today, the pair are generated by an instance of pairing model
        :param save_to_db: If true, it wills save the object into the database
        """
        super().__init__()
        self.name = name
        self.time_start = str(datetime.now())
        self.time_end = None
        self.is_finished = False
        self.matches = []
        if matches_pairs:
            self.matches_pairs = matches_pairs
            self.create_matches()
        if save_to_db:
            self.save_to_database()

    @classmethod
    def _create_instance_from_json(cls,
                                   item_data: dict[str, object],
                                   round_id: str,
                                   save_to_db: bool = False):
        """
        Create a round object from a json dictionary.
        Instantiate matches from their corresponding id found in the database
        :param item_data:
        :param round_id:
        :param save_to_db: must be false to avoid copy of round instance in database
        :return: An instance of Player
        """
        instance = cls(name=item_data["name"],
                       save_to_db=False)
        instance.software_id = round_id
        instance.time_start = item_data["time_start"]
        instance.time_end = item_data["time_end"]
        instance.is_finished = item_data["complete"]
        instance.matches = [Match.from_json(match_id) for match_id in item_data["matches"]]
        return instance

    def _prepare_data_to_save(self) -> dict:
        """
        Prepare data to save in the database.
        :return: dictionary with data to save in the database
        """
        data = {
            "name": self.name,
            "time_start": self.time_start,
            "time_end": self.time_end,
            "complete": self.is_finished,
            "matches": [match.software_id for match in self.matches]
        }
        return data

    def create_matches(self):
        """
        Create Match Instance from pairs of players.
        :return:
        """
        for pair in self.matches_pairs:
            match = Match(pair[0], pair[1])
            self.matches.append(match)

    def end_round(self):
        """
        End the round if every match is finished
        Save the state of the round and the time it was completed in the database.
        """
        if not self.is_finished:
            for match in self.matches:
                if not match.is_finished:
                    print(f"Match with ID : {match.software_id} is not finished")
                    return
            self.time_end = str(datetime.now())
            self.is_finished = True
            self.save_to_database()
        else:
            raise ValueError("Round is already finished")

    def get_match_by_player_id(self, player_id: str):
        """
        Get a Match object in the Round where a Player_id is participating
        :param player_id:
        :return: Match object
        """
        for match in self.matches:
            if player_id in match.score.keys():
                return match
        return None

    def check_match_result(self):
        """
        Show the results of every match in the round.
        """
        for match in self.matches:
            print(f"{match.software_id} : {match.score}")

    def __repr__(self) -> str:
        return (f"Round : {self.name}, Matches: {[match.software_id for match in self.matches]}, "
                f"Started: {self.time_start}, Ended: {self.time_end}")


def main():
    """
    Temporary function to test methods and objects
    :return:
    """

    # round_1 = Round("Round x", matches_pairs={('p_3', 'p_5'), ('p_1', 'p_4')})
    # print(round_1)
    # print(round_1.matches[0].is_finished)
    # print(round_1.matches[1].is_finished)
    # value = input("just to delay exec")
    # print(value)
    # round_1.end_round()
    # round_1.save_to_database()

    round_2 = Round.from_json("r_1")
    print(round_2.get_match_by_player_id('p_1'))
    match_p = round_2.get_match_by_player_id('p_1')
    match_p.draw()
    print(round_2.matches[0].is_finished)
    print(round_2.matches[1].is_finished)
    round_2.check_match_result()


if __name__ == '__main__':
    main()
